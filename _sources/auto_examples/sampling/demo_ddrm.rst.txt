
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/sampling/demo_ddrm.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        New to DeepInverse? Get started with the basics with the
        :ref:`5 minute quickstart tutorial <sphx_glr_auto_examples_basics_demo_quickstart.py>`.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_sampling_demo_ddrm.py:


Image reconstruction with a diffusion model
====================================================================================================

This code shows you how to use the DDRM diffusion algorithm :footcite:t:`kawar2022denoising` to reconstruct images and also compute the
uncertainty of a reconstruction from incomplete and noisy measurements.

The DDRM method requires that:

* The operator has a singular value decomposition (i.e., the operator is a :class:`deepinv.physics.DecomposablePhysics`).
* The noise is Gaussian with known standard deviation (i.e., the noise model is :class:`deepinv.physics.GaussianNoise`).

.. GENERATED FROM PYTHON SOURCE LINES 13-20

.. code-block:: Python


    import deepinv as dinv
    from deepinv.utils.plotting import plot
    import torch
    import numpy as np
    from deepinv.utils.demo import load_url_image








.. GENERATED FROM PYTHON SOURCE LINES 21-25

Load example image from the internet
--------------------------------------------------------------

This example uses an image of Lionel Messi from Wikipedia.

.. GENERATED FROM PYTHON SOURCE LINES 25-35

.. code-block:: Python


    device = dinv.utils.get_freer_gpu() if torch.cuda.is_available() else "cpu"

    url = (
        "https://upload.wikimedia.org/wikipedia/commons/b/b4/"
        "Lionel-Messi-Argentina-2022-FIFA-World-Cup_%28cropped%29.jpg"
    )
    x = load_url_image(url=url, img_size=32).to(device)









.. GENERATED FROM PYTHON SOURCE LINES 36-40

Define forward operator and noise model
--------------------------------------------------------------

We use image inpainting as the forward operator and Gaussian noise as the noise model.

.. GENERATED FROM PYTHON SOURCE LINES 40-50

.. code-block:: Python


    sigma = 0.1  # noise level
    physics = dinv.physics.Inpainting(
        mask=0.5,
        img_size=x.shape[1:],
        device=device,
        noise_model=dinv.physics.GaussianNoise(sigma=sigma),
    )









.. GENERATED FROM PYTHON SOURCE LINES 51-56

Define the MMSE denoiser
--------------------------------------------------------------

The diffusion method requires an MMSE denoiser that can be evaluated a various noise levels.
Here we use a pretrained DRUNET denoiser from the :ref:`denoisers <denoisers>` module.

.. GENERATED FROM PYTHON SOURCE LINES 56-59

.. code-block:: Python


    denoiser = dinv.models.DRUNet(pretrained="download").to(device)








.. GENERATED FROM PYTHON SOURCE LINES 60-67

Create the Monte Carlo sampler
--------------------------------------------------------------

We can now reconstruct a noisy measurement using the diffusion method.
We use the DDRM method from :class:`deepinv.sampling.DDRM`, which works with inverse problems that
have a closed form singular value decomposition of the forward operator.
The diffusion method requires a schedule of noise levels ``sigmas`` that are used to evaluate the denoiser.

.. GENERATED FROM PYTHON SOURCE LINES 67-72

.. code-block:: Python


    sigmas = np.linspace(1, 0, 100) if torch.cuda.is_available() else np.linspace(1, 0, 10)

    diff = dinv.sampling.DDRM(denoiser=denoiser, etab=1.0, sigmas=sigmas, verbose=True)








.. GENERATED FROM PYTHON SOURCE LINES 73-76

Generate the measurement
---------------------------------------------------------------------------------
We apply the forward model to generate the noisy measurement.

.. GENERATED FROM PYTHON SOURCE LINES 76-79

.. code-block:: Python


    y = physics(x)








.. GENERATED FROM PYTHON SOURCE LINES 80-84

Run the diffusion algorithm and plot results
---------------------------------------------------------------------------------
The diffusion algorithm returns a sample from the posterior distribution.
We compare the posterior mean with a simple linear reconstruction.

.. GENERATED FROM PYTHON SOURCE LINES 84-99

.. code-block:: Python


    xhat = diff(y, physics)

    # compute linear inverse
    x_lin = physics.A_adjoint(y)

    # compute PSNR
    print(f"Linear reconstruction PSNR: {dinv.metric.PSNR()(x, x_lin).item():.2f} dB")
    print(f"Diffusion PSNR: {dinv.metric.PSNR()(x, xhat).item():.2f} dB")

    # plot results
    error = (xhat - x).abs().sum(dim=1).unsqueeze(1)  # per pixel average abs. error
    imgs = [x_lin, x, xhat]
    plot(imgs, titles=["measurement", "ground truth", "DDRM reconstruction"])




.. image-sg:: /auto_examples/sampling/images/sphx_glr_demo_ddrm_001.png
   :alt: measurement, ground truth, DDRM reconstruction
   :srcset: /auto_examples/sampling/images/sphx_glr_demo_ddrm_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

      0%|          | 0/9 [00:00<?, ?it/s]     33%|███▎      | 3/9 [00:00<00:00, 26.09it/s]     67%|██████▋   | 6/9 [00:00<00:00, 26.20it/s]    100%|██████████| 9/9 [00:00<00:00, 26.36it/s]    100%|██████████| 9/9 [00:00<00:00, 26.28it/s]
    Linear reconstruction PSNR: 8.80 dB
    Diffusion PSNR: 22.87 dB




.. GENERATED FROM PYTHON SOURCE LINES 100-107

Create a Monte Carlo sampler
---------------------------------------------------------------------------------
Running the diffusion gives a single sample of the posterior distribution.
In order to compute the posterior mean and variance, we can use multiple samples.
This can be done using the :class:`deepinv.sampling.DiffusionSampler` class, which converts
the diffusion algorithm into a fully fledged Monte Carlo sampler.
We set the maximum number of iterations to 10, which means that the sampler will run the diffusion 10 times.

.. GENERATED FROM PYTHON SOURCE LINES 107-111

.. code-block:: Python


    f = dinv.sampling.DiffusionSampler(diff, max_iter=10)









.. GENERATED FROM PYTHON SOURCE LINES 112-116

Run sampling algorithm and plot results
---------------------------------------------------------------------------------
The sampling algorithm returns the posterior mean and variance.
We compare the posterior mean with a simple linear reconstruction.

.. GENERATED FROM PYTHON SOURCE LINES 116-144

.. code-block:: Python


    mean, var = f(y, physics)

    # compute PSNR
    print(f"Linear reconstruction PSNR: {dinv.metric.PSNR()(x, x_lin).item():.2f} dB")
    print(f"Posterior mean PSNR: {dinv.metric.PSNR()(x, mean).item():.2f} dB")

    # plot results
    error = (mean - x).abs().sum(dim=1).unsqueeze(1)  # per pixel average abs. error
    std = var.sum(dim=1).unsqueeze(1).sqrt()  # per pixel average standard dev.
    imgs = [
        x_lin,
        x,
        mean,
        std / std.flatten().max(),
        error / error.flatten().max(),
    ]
    plot(
        imgs,
        titles=[
            "measurement",
            "ground truth",
            "post. mean",
            "post. std",
            "abs. error",
        ],
    )




.. image-sg:: /auto_examples/sampling/images/sphx_glr_demo_ddrm_002.png
   :alt: measurement, ground truth, post. mean, post. std, abs. error
   :srcset: /auto_examples/sampling/images/sphx_glr_demo_ddrm_002.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

      0%|          | 0/10 [00:00<?, ?it/s]     10%|█         | 1/10 [00:00<00:03,  2.64it/s]     20%|██        | 2/10 [00:00<00:03,  2.65it/s]     30%|███       | 3/10 [00:01<00:02,  2.65it/s]     40%|████      | 4/10 [00:01<00:02,  2.65it/s]     50%|█████     | 5/10 [00:01<00:01,  2.65it/s]     60%|██████    | 6/10 [00:02<00:01,  2.65it/s]     70%|███████   | 7/10 [00:02<00:01,  2.65it/s]     80%|████████  | 8/10 [00:03<00:00,  2.65it/s]     90%|█████████ | 9/10 [00:03<00:00,  2.65it/s]    100%|██████████| 10/10 [00:03<00:00,  2.65it/s]    100%|██████████| 10/10 [00:03<00:00,  2.65it/s]
    Iteration 9, current converge crit. = 9.07E-03, objective = 1.00E-01 
    Iteration 9, current converge crit. = 9.67E-02, objective = 1.00E-01 
    Linear reconstruction PSNR: 8.80 dB
    Posterior mean PSNR: 22.34 dB




.. GENERATED FROM PYTHON SOURCE LINES 145-148

:References:

.. footbibliography::


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 4.649 seconds)


.. _sphx_glr_download_auto_examples_sampling_demo_ddrm.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: demo_ddrm.ipynb <demo_ddrm.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: demo_ddrm.py <demo_ddrm.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: demo_ddrm.zip <demo_ddrm.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
